# Here the docker-compose file is referencing the tomcat server Dockerfile that will be used to build and provision our first Liferay instance bundled with a Tomcat server.
# It is also configuring a few other options for the service.

# The build command let's docker-compose know where to look for the tomcat server Dockerfile that provides configurations that will be applied to the service at build time.

# We'll take a look at this Dockerfile in a moment.

# The container_name option gives the container it's custom name ("liferay-tomcat-1").

# The depends_on configuration declares any dependencies between services. In this case the liferay-tomcat-1 service will require a mysql service as a dependency.
# You'll also see that the apacheds and elasticsearch dependencies have been commented out. We'll look at these a little more closely later on. All of these services are defined in the docker-compose file and in their respective Dockerfiles. They'll be started up in the order defined in the file (initially mysql → liferay-tomcat-1 and ultimately apacheds → elasticsearch → mysql → liferay-tomcat-1).

# The networks configuration specifies which network the service is to join.
# This allows containers to be both reachable and discoverable by other containers on the network.

# The ports configuration maps the ports for the service. The first port is the host port. The second is the container port

# Finally the volume configuration mounts the named volume volume-liferay-tomcat-data to a specified directory in the container.
# In this case the volume is mounted to /opt/liferay/data in the container. Named volumes can be declared at the bottom of the docker-compose file:

version: "3.8"
services:
#  apacheds:
#    build: apacheds
#    container_name: apacheds
#    networks:
#      - network-liferay74-tomcat
#    ports:
#      - 10389:10389
#    volumes:
#      - volume-apacheds:/opt/liferay/apacheds-2.0.0.AM25/instances
  es01:
    build: elasticsearch
#    image: elasticsearch:7.17.6
    container_name: es01
    environment:
      - xpack.security.enabled=false
      - node.name=es01
      - node.data=true
      - node.ingest=false
      - node.master=true
      - node.ml=false
      - search.remote.connect=false
      - network.host=es01
      - cluster.name=LiferayElasticsearchCluster01
      - cluster.initial_master_nodes=es01
      #- discovery.seed_hosts=es02,es03
      - discovery.seed_hosts=es01,es02
      - bootstrap.memory_lock=true
      - discovery.zen.minimum_master_nodes=1
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - volume-elasticsearch74-01:/usr/share/elasticsearch/data
    ports:
      - 9200:9200
      - 9300:9300
    networks:
      - network-liferay74-tomcat
  es02:
    build: elasticsearch
    #image: docker.elastic.co/elasticsearch/elasticsearch:6.5.4
    container_name: es02
    environment:
      - xpack.security.enabled=false
      - node.name=es02
      - node.data=true
      - node.ingest=true
      - node.master=true
      - node.ml=false
      - search.remote.connect=false
      - network.host=es02
      - cluster.name=LiferayElasticsearchCluster01
      - cluster.initial_master_nodes=es01
      #- discovery.seed_hosts=es02,es03
      # http://localhost:9400/_cluster/health
      - discovery.seed_hosts=es01,es02
      - bootstrap.memory_lock=true
      - discovery.zen.minimum_master_nodes=1
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - volume-elasticsearch74-02:/usr/share/elasticsearch/data
    ports:
      - 9400:9200
      - 9500:9300
    ulimits:
      memlock:
        soft: -1
        hard: -1
    networks:
      - network-liferay74-tomcat
  liferay74-tomcat-1:
    build: liferay74-tomcat
    container_name: liferay74-tomcat-1
    depends_on:
      - mysql
      - es01
      - es02
    networks:
      - network-liferay74-tomcat
    ports:
      - 8081:8080
      - 127.0.0.1:11311:11311
    volumes:
      - volume-liferay74-tomcat-data:/opt/liferay/data
      - volume-liferay74-tomcat-1-work:/opt/liferay/tomcat/work
  liferay74-tomcat-2:
    build: liferay74-tomcat
    container_name: liferay74-tomcat-2
    depends_on:
      - mysql
      - es01
      - es02
    networks:
      - network-liferay74-tomcat
    ports:
      - 8082:8080
      - 127.0.0.1:21311:11311
    volumes:
      - volume-liferay74-tomcat-data:/opt/liferay/data
      - volume-liferay74-tomcat-2-work:/opt/liferay/tomcat/work
  haproxy:
    build: haproxy
    container_name: haproxy
    networks:
      - network-liferay74-tomcat
    ports:
      - 9002:80
      - 9999:9999
  mysql:
    image: mysql:8.0.31-oracle
    container_name: mysql8
    networks:
      - network-liferay74-tomcat
    ports:
      - 3307:3306
    environment:
      MYSQL_USER: liferay
      MYSQL_DATABASE: lportal
      MYSQL_PASSWORD: liferay
      MYSQL_ROOT_PASSWORD: liferay
    volumes:
      - volume-mysql8:/var/lib/mysql
networks:
  network-liferay74-tomcat:
    name: network-liferay74-tomcat
volumes:
#  volume-apacheds:
  volume-elasticsearch74-01:
  volume-elasticsearch74-02:
  volume-liferay74-tomcat-data:
  volume-liferay74-tomcat-1-work:
  volume-liferay74-tomcat-2-work:
  volume-mysql8:


# docker-compose rm --all &&
#docker-compose pull &&
#docker-compose build --no-cache &&
#docker-compose up -d --force-recreate &&

#https://help.liferay.com/hc/en-us/articles/360035940151-Using-singleton-name-in-tcp-xml-Liferay-7-2-fix-pack-1-TCPping-cluster-fails-to-start-up
#remove singleton_name

# Volumes are the best way to persist data from a Docker container and should be used in production environments.
#  Volumes differ from Bind Mounts which are often used in testing settings.
# A bind mount will mount a designated folder or file on the host machine to your container.
# The container will access the folder or file on the host at the relative or absolute path given when creating the bind mount. While this initially may seem like an easy way to manage files and folders, especially on a smaller scale, it can lead to issues if the host machine's directory structure changes and the file or folder is removed from where a container expects it to be. In this sense, bind mounts must be managed manually.
# In contrast, when a Volume is created Docker automatically generates a new directory in Docker's storage base alongside the containers and images you've created.
#  Docker will then automatically manage the folder's content.
# When a Volume is mounted to a container, much like the bind mount, the folder generated by Docker is mounted to a specified location in the container, but paths are all managed by Docker to avoid the issues common to bind mounts.
# Additionally, a single Volume can be simultaneously mounted to multiple containers.
# And by taking advantage of Volume drivers, you can safely store Volume data on a remote host or cloud service.
# Volumes can be created explicitly, as we do in our docker-compose file, or can be generated automatically when creating a new service or container.

# Run the following command to build the liferay-tomcat-1 image:
#       docker-compose build liferay-tomcat-1
# Run the following command to build the mysql image:
#       docker-compose build mysql
# Run the following command to start up the liferay-tomcat-1 service:
#       docker-compose up -d liferay-tomcat-1
# The docker-compose up command will build the image if it isn't already built, create and start the container and attach any services required by the container. In our case the command will start the multiple services that liferay-tomcat-1 requires (as determined in the docker-compose.yml file) before it creates and starts the tomcat container.
